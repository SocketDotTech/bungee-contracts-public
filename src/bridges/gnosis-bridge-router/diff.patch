--- src/bridges/gnosis-native/gnosisNativeImpl.sol	2025-07-24 14:40:52
+++ src/bridges/gnosis-bridge-router/GnosisBridgeRouterImpl.sol	2025-07-28 20:33:12
@@ -1,90 +1,71 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.4;
 
-import "../BridgeImplBase.sol";
-import "./interfaces/gnosisBirdge.sol";
 import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";
 import {ERC20} from "solmate/tokens/ERC20.sol";
-import {IGnosisXdaiBridge, IGnosisOmniBridge, IGnosisWethOmniBridgeHelper} from "./interfaces/gnosisBirdge.sol";
-import {GNOSIS_NATIVE_BRIDGE} from "../../static/RouteIdentifiers.sol";
 
+import {BridgeImplBase} from "../BridgeImplBase.sol";
+import {IGnosisBridgeRouter} from "./interfaces/IGnosisBridgeRouter.sol";
+import {GNOSIS_BRIDGE_ROUTER} from "../../static/RouteIdentifiers.sol";
+
 /**
- * @title Symbiosis-Route Implementation
- * @notice Route implementation with functions to bridge ERC20 and Native via Symbiosis-Bridge
- * Called via SocketGateway if the routeId in the request maps to the routeId of SymbiosisImplementation
- * Contains function to handle bridging as post-step i.e linked to a preceeding step for swap
- * RequestData is different to just bride and bridging chained with swap
+ * @title Gnosis Bridge Router Implementation
+ * @notice Route implementation with functions to bridge ERC20 and Native tokens via Gnosis Bridge Router
+ * Called via SocketGateway if the routeId in the request maps to the routeId of GnosisBridgeRouterImpl
+ * Contains function to handle bridging as post-step i.e linked to a preceding step for swap
  * @author Socket dot tech.
  */
-
-contract GnosisNativeBridgeImpl is BridgeImplBase {
-    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens
+contract GnosisBridgeRouterImpl is BridgeImplBase {
     using SafeTransferLib for ERC20;
 
-    bytes32 public immutable GnosisNativeBridgeIdentifier =
-        GNOSIS_NATIVE_BRIDGE;
+    bytes32 public immutable GnosisBridgeRouterIdentifier =
+        GNOSIS_BRIDGE_ROUTER;
 
     /// @notice max value for uint256
     uint256 public constant UINT256_MAX = type(uint256).max;
 
-    /// @notice Function-selector for ERC20-token bridging on Symbiosis-Route
-    /// @dev This function selector is to be used while buidling transaction-data to bridge ERC20 tokens
+    /// @notice Function-selector for ERC20-token bridging on Gnosis-Bridge-Router
+    /// @dev This function selector is to be used while building transaction-data to bridge ERC20 tokens
     bytes4
-        public immutable GNOSIS_NATIVE_BRIDGE_ERC20_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =
-        bytes4(
-            keccak256(
-                "bridgeERC20To(bytes32,address,address,address,uint256,uint256)"
-            )
-        );
+        public immutable GNOSIS_BRIDGE_ROUTER_ERC20_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =
+        GnosisBridgeRouterImpl.bridgeERC20To.selector;
 
-    /// @notice Function-selector for Native bridging on Symbiosis-Route
-    /// @dev This function selector is to be used while buidling transaction-data to bridge Native tokens
+    /// @notice Function-selector for Native bridging on Gnosis-Bridge-Router
+    /// @dev This function selector is to be used while building transaction-data to bridge Native tokens
     bytes4
-        public immutable GNOSIS_NATIVE_BRIDGE_NATIVE_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =
-        bytes4(keccak256("bridgeNativeTo(bytes32,address,uint256,uint256)"));
+        public immutable GNOSIS_BRIDGE_ROUTER_NATIVE_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =
+        GnosisBridgeRouterImpl.bridgeNativeTo.selector;
 
-    bytes4 public immutable GNOSIS_NATIVE_BRIDGE_SWAP_BRIDGE_SELECTOR =
-        bytes4(
-            keccak256(
-                "swapAndBridge(uint32,bytes,bytes32,address,address,uint256)"
-            )
-        );
+    /// @notice Function-selector for ERC20-token bridging on Gnosis-Bridge-Router
+    /// @dev This function selector is to be used while building transaction-data to bridge ERC20 tokens
+    bytes4 public immutable GNOSIS_BRIDGE_ROUTER_SWAP_BRIDGE_SELECTOR =
+        GnosisBridgeRouterImpl.swapAndBridge.selector;
 
-    struct GnosisNativeBridgeData {
+    struct GnosisBridgeRouterData {
         bytes32 metadata;
         address receiverAddress;
         address fromTokenAddress;
-        address toTokenAddress;
         uint256 toChainId;
         uint256 amount;
     }
 
-    /// @notice The contract address of the Symbiosis router on the source chain
-    IGnosisXdaiBridge private immutable gnosisXdaiBridge;
-    IGnosisOmniBridge private immutable gnosisOmniBridge;
-    IGnosisWethOmniBridgeHelper private immutable gnosisWethOmniBridgeHelper;
+    /// @notice The contract address of the Gnosis BridgeRouter on the source chain
+    IGnosisBridgeRouter private immutable gnosisBridgeRouter;
 
     constructor(
-        address _gnosisXdaiBridge,
-        address _gnosisOmniBridge,
-        address _gnosisWethOmniBridgeHelper,
+        address _gnosisBridgeRouter,
         address _socketGateway,
         address _socketDeployFactory
     ) BridgeImplBase(_socketGateway, _socketDeployFactory) {
-        gnosisXdaiBridge = IGnosisXdaiBridge(_gnosisXdaiBridge);
-        gnosisOmniBridge = IGnosisOmniBridge(_gnosisOmniBridge);
-        gnosisWethOmniBridgeHelper = IGnosisWethOmniBridgeHelper(
-            _gnosisWethOmniBridgeHelper
-        );
+        gnosisBridgeRouter = IGnosisBridgeRouter(_gnosisBridgeRouter);
     }
 
     /**
-     * @notice function to handle ERC20 bridging to receipent via Gnosis Native Bridge
-     * @notice This method is payable because the caller is doing token transfer and briding operation
+     * @notice function to handle ERC20 bridging to recipient via Gnosis BridgeRouter
+     * @notice This method is payable because the caller is doing token transfer and bridging operation
      * @param metadata  socket offchain created hash
-     * @param receiverAddress address of the token to bridged to the destination chain.
+     * @param receiverAddress address of the receiver on the destination chain.
      * @param fromTokenAddress address of token being bridged
-     * @param toTokenAddress address of token to receive at dest chain
      * @param toChainId chainId of destination
      * @param amount amount to be bridged
      */
@@ -92,60 +73,42 @@
         bytes32 metadata,
         address receiverAddress,
         address fromTokenAddress,
-        address toTokenAddress,
         uint256 toChainId,
         uint256 amount
     ) external payable {
         ERC20(fromTokenAddress).safeTransferFrom(
             msg.sender,
-            socketGateway,
+            address(this),
             amount
         );
 
-        // if from fromToken is DAI on mainnet and
-        // toToken is native DAI on Gnosis use xDaiBridge
-        if (toTokenAddress == NATIVE_TOKEN_ADDRESS) {
-            if (
-                amount >
-                ERC20(fromTokenAddress).allowance(
-                    address(this),
-                    address(gnosisXdaiBridge)
-                )
-            ) {
-                ERC20(fromTokenAddress).safeApprove(
-                    address(gnosisXdaiBridge),
-                    UINT256_MAX
-                );
-            }
-
-            gnosisXdaiBridge.relayTokens(receiverAddress, amount);
-        } else {
-            // other ERC20 tokens use omni bridge
-            if (
-                amount >
-                ERC20(fromTokenAddress).allowance(
-                    address(this),
-                    address(gnosisOmniBridge)
-                )
-            ) {
-                ERC20(fromTokenAddress).safeApprove(
-                    address(gnosisOmniBridge),
-                    UINT256_MAX
-                );
-            }
-
-            gnosisOmniBridge.relayTokens(
-                fromTokenAddress,
-                receiverAddress,
-                amount
+        // approve Gnosis BridgeRouter if required
+        if (
+            amount >
+            ERC20(fromTokenAddress).allowance(
+                address(this),
+                address(gnosisBridgeRouter)
+            )
+        ) {
+            ERC20(fromTokenAddress).safeApprove(
+                address(gnosisBridgeRouter),
+                UINT256_MAX
             );
         }
 
+        // if fromToken is DAI, USDS or any ERC20 token use BridgeRouter directly
+        /// @dev BridgeRouter will handle each ERC20 token accordingly
+        gnosisBridgeRouter.relayTokens(
+            fromTokenAddress,
+            receiverAddress,
+            amount
+        );
+
         emit SocketBridge(
             amount,
             fromTokenAddress,
             toChainId,
-            GnosisNativeBridgeIdentifier,
+            GnosisBridgeRouterIdentifier,
             msg.sender,
             receiverAddress,
             metadata
@@ -153,10 +116,10 @@
     }
 
     /**
-     * @notice function to handle Native bridging to receipent via Gnosis Native Bridge
-     * @notice This method is payable because the caller is doing token transfer and briding operation
+     * @notice function to handle Native bridging to recipient via Gnosis BridgeRouter
+     * @notice This method is payable because the caller is doing token transfer and bridging operation
      * @param metadata  socket offchain created hash
-     * @param receiverAddress address of the token to bridged to the destination chain.
+     * @param receiverAddress address of the receiver on the destination chain.
      * @param toChainId chainId of destination
      * @param amount amount to be bridged
      */
@@ -166,15 +129,19 @@
         uint256 toChainId,
         uint256 amount
     ) external payable {
-        gnosisWethOmniBridgeHelper.wrapAndRelayTokens{value: amount}(
-            receiverAddress
+        /// @dev BridgeRouter will handle the Native token accordingly
+        /// @dev BridgeRouter uses zero address as native token
+        gnosisBridgeRouter.relayTokens{value: amount}(
+            address(0),
+            receiverAddress,
+            amount
         );
 
         emit SocketBridge(
             amount,
             NATIVE_TOKEN_ADDRESS,
             toChainId,
-            GnosisNativeBridgeIdentifier,
+            GnosisBridgeRouterIdentifier,
             msg.sender,
             receiverAddress,
             metadata
@@ -183,82 +150,60 @@
 
     /**
      * @notice function to bridge tokens after swap.
-     * @notice this is different from swapAndBridge, this function is called when the swap has already happened at a different place.
-     * @notice This method is payable because the caller is doing token transfer and briding operation
+     * @notice this is different from swapAndBridge, this is called when the swap has already happened before this is called.
+     * @notice This method is payable because the caller is doing token transfer and bridging operation
      * @dev for usage, refer to controller implementations
-     *      encodedData for bridge should follow the sequence of properties in GnosisNativeBridgeData struct
+     *      encodedData for bridge should follow the sequence of properties in GnosisBridgeRouterData struct
      * @param amount amount of tokens being bridged. this can be ERC20 or native
-     * @param bridgeData encoded data for Gnosis Native Bridge
+     * @param bridgeData encoded data for Gnosis BridgeRouter
      */
     function bridgeAfterSwap(
         uint256 amount,
         bytes calldata bridgeData
     ) external payable override {
-        GnosisNativeBridgeData memory bridgeInfo = abi.decode(
+        GnosisBridgeRouterData memory bridgeInfo = abi.decode(
             bridgeData,
-            (GnosisNativeBridgeData)
+            (GnosisBridgeRouterData)
         );
 
-        // if from token is native ETH, use OmniBridge Weth helper contract
-        // It wraps native ETH to WETH and bridges to to WETH on Gnosis
+        // if fromToken is native ETH, use BridgeRouter directly
         if (bridgeInfo.fromTokenAddress == NATIVE_TOKEN_ADDRESS) {
-            gnosisWethOmniBridgeHelper.wrapAndRelayTokens{value: amount}(
-                bridgeInfo.receiverAddress
+            /// @dev BridgeRouter will handle the Native token accordingly
+            /// @dev BridgeRouter uses zero address as native token
+            gnosisBridgeRouter.relayTokens{value: amount}(
+                address(0),
+                bridgeInfo.receiverAddress,
+                amount
             );
 
             emit SocketBridge(
                 amount,
                 NATIVE_TOKEN_ADDRESS,
                 bridgeInfo.toChainId,
-                GnosisNativeBridgeIdentifier,
+                GnosisBridgeRouterIdentifier,
                 msg.sender,
                 bridgeInfo.receiverAddress,
                 bridgeInfo.metadata
             );
         }
-        // if  from token is DAI on ethereum and toToken is xDai on Gnosis  use xdaiBridge
-        else if (bridgeInfo.toTokenAddress == NATIVE_TOKEN_ADDRESS) {
-            if (
-                amount >
-                ERC20(bridgeInfo.fromTokenAddress).allowance(
-                    address(this),
-                    address(gnosisXdaiBridge)
-                )
-            ) {
-                ERC20(bridgeInfo.fromTokenAddress).safeApprove(
-                    address(gnosisXdaiBridge),
-                    UINT256_MAX
-                );
-            }
-
-            gnosisXdaiBridge.relayTokens(bridgeInfo.receiverAddress, amount);
-
-            emit SocketBridge(
-                amount,
-                bridgeInfo.fromTokenAddress,
-                bridgeInfo.toChainId,
-                GnosisNativeBridgeIdentifier,
-                msg.sender,
-                bridgeInfo.receiverAddress,
-                bridgeInfo.metadata
-            );
-        }
-        // other ERC20 tokens use omni bridge
+        // if fromToken is DAI, USDS or any ERC20 token use BridgeRouter directly
         else {
+            // approve Gnosis BridgeRouter if required
             if (
                 amount >
                 ERC20(bridgeInfo.fromTokenAddress).allowance(
                     address(this),
-                    address(gnosisOmniBridge)
+                    address(gnosisBridgeRouter)
                 )
             ) {
                 ERC20(bridgeInfo.fromTokenAddress).safeApprove(
-                    address(gnosisOmniBridge),
+                    address(gnosisBridgeRouter),
                     UINT256_MAX
                 );
             }
 
-            gnosisOmniBridge.relayTokens(
+            /// @dev BridgeRouter will handle each ERC20 token accordingly
+            gnosisBridgeRouter.relayTokens(
                 bridgeInfo.fromTokenAddress,
                 bridgeInfo.receiverAddress,
                 amount
@@ -268,7 +213,7 @@
                 amount,
                 bridgeInfo.fromTokenAddress,
                 bridgeInfo.toChainId,
-                GnosisNativeBridgeIdentifier,
+                GnosisBridgeRouterIdentifier,
                 msg.sender,
                 bridgeInfo.receiverAddress,
                 bridgeInfo.metadata
@@ -279,14 +224,13 @@
     /**
      * @notice function to bridge tokens after swap.
      * @notice this is different from bridgeAfterSwap since this function holds the logic for swapping tokens too.
-     * @notice This method is payable because the caller is doing token transfer and briding operation
+     * @notice This method is payable because the caller is doing token transfer and bridging operation
      * @dev for usage, refer to controller implementations
      *      encodedData for bridge should follow the sequence of properties in SymbiosisBridgeData struct
      * @param swapId routeId for the swapImpl
      * @param swapData encoded data for swap
      * @param metadata  socket offchain created hash
      * @param receiverAddress   address of the token to bridged to the destination chain.
-     * @param toTokenAddress address of token being bridged
      * @param toChainId chainId of destination
      */
     function swapAndBridge(
@@ -294,7 +238,6 @@
         bytes calldata swapData,
         bytes32 metadata,
         address receiverAddress,
-        address toTokenAddress,
         uint256 toChainId
     ) external payable {
         (bool success, bytes memory result) = socketRoute
@@ -312,66 +255,54 @@
             (uint256, address)
         );
 
-        // if from token is native ETH, use OmniBridge Weth helper contract
-        // It wraps native ETH to WETH and bridges to to WETH on Gnosis
+        // if fromToken is native ETH, use BridgeRouter directly
         if (token == NATIVE_TOKEN_ADDRESS) {
-            gnosisWethOmniBridgeHelper.wrapAndRelayTokens{value: bridgeAmount}(
-                receiverAddress
+            /// @dev BridgeRouter will handle the Native token accordingly
+            /// @dev BridgeRouter uses zero address as native token
+            gnosisBridgeRouter.relayTokens{value: bridgeAmount}(
+                address(0),
+                receiverAddress,
+                bridgeAmount
             );
 
             emit SocketBridge(
                 bridgeAmount,
                 NATIVE_TOKEN_ADDRESS,
                 toChainId,
-                GnosisNativeBridgeIdentifier,
+                GnosisBridgeRouterIdentifier,
                 msg.sender,
                 receiverAddress,
                 metadata
             );
         }
-        // if  from token is DAI on ethereum and toToken is xDai on Gnosis  use xdaiBridge
-        else if (toTokenAddress == NATIVE_TOKEN_ADDRESS) {
+        // if fromToken is DAI, USDS or any ERC20 token use BridgeRouter directly
+        else {
+            // approve Gnosis BridgeRouter if required
             if (
                 bridgeAmount >
-                ERC20(token).allowance(address(this), address(gnosisXdaiBridge))
+                ERC20(token).allowance(
+                    address(this),
+                    address(gnosisBridgeRouter)
+                )
             ) {
                 ERC20(token).safeApprove(
-                    address(gnosisXdaiBridge),
+                    address(gnosisBridgeRouter),
                     UINT256_MAX
                 );
             }
 
-            gnosisXdaiBridge.relayTokens(receiverAddress, bridgeAmount);
-
-            emit SocketBridge(
-                bridgeAmount,
+            /// @dev BridgeRouter will handle each ERC20 token accordingly
+            gnosisBridgeRouter.relayTokens(
                 token,
-                toChainId,
-                GnosisNativeBridgeIdentifier,
-                msg.sender,
                 receiverAddress,
-                metadata
+                bridgeAmount
             );
-        }
-        // other ERC20 tokens use omni bridge
-        else {
-            if (
-                bridgeAmount >
-                ERC20(token).allowance(address(this), address(gnosisOmniBridge))
-            ) {
-                ERC20(token).safeApprove(
-                    address(gnosisOmniBridge),
-                    UINT256_MAX
-                );
-            }
 
-            gnosisOmniBridge.relayTokens(token, receiverAddress, bridgeAmount);
-
             emit SocketBridge(
                 bridgeAmount,
                 token,
                 toChainId,
-                GnosisNativeBridgeIdentifier,
+                GnosisBridgeRouterIdentifier,
                 msg.sender,
                 receiverAddress,
                 metadata
